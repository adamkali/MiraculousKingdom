use axum::{
    Extension,
    http::StatusCode,
    Json,
    extract::Path,
};
use mongodb::{
    Database,
    bson::{
        oid::ObjectId,
        doc
    },
};
use crate::data_types::{
    characters::Character,
    common::{
        DetailedResponse,
        VecCharDetailedResponse,
        CharDetialedResponse,
    }
};
use futures::stream::TryStreamExt;

/// Endpoint to find all characters that the players is participating in for their specific secret. 
///
/// # Example
///
/// ```
/// GET /api/character/{secret}
/// ```
///
/// # Parameters
///
/// - `secret`: String set by the user. Should keep the same. For now too lazy to fix ðŸ‘¿
///
/// # Responses
///
/// - `200 OK`: Found characters with secret_code: {secret}
///
///     ```json
///     {
///         "code": 200,
///         "message": "Found characters with secret_code: {secret}",
///         "success": true,
///         "data": [
///             {
///                 "char_name": "character_name",
///                 ...
///             },
///             ...
///         ]
///     }
///     ```
///
/// - `500 Internal Server Error`: An internal error occurred.
///
///     ```json
///     {
///         "code": 500,
///         "success": false
///         "message": "Internal error occurred",
///         "data": []
///     }
///     ```
///
#[utoipa::path(
    get,
    path = "/api/character/{secret}",
    responses((
        status = 200, 
        description = "Found characters with secret_code: {secret}", 
        body = VecCharDetailedResponse,
    ),
    (
        status = 500, 
        description = "Internal error occured", 
        body = VecCharDetailedResponse 
    )),
    params(
        (
            "secret" = String, 
            Path, 
            description = "String set by the user to get their data"
        )
    )
)]
pub async fn get_characters(
    Extension(mongo): Extension<Database>,
    Path(secret): Path<String>
) -> Json<DetailedResponse<Vec<Character>>> {
    let mut response =
        DetailedResponse::new(Vec::<Character>::new());

    let collection = mongo.clone().collection::<Character>("characters");
    let cursor = collection.find(
        doc! {
            "secret": secret.clone(),
        }, 
        None
    ).await;

    match cursor {
        Ok(mut c) => {
            while let Ok(res) = c.try_next().await {
                match res {
                    Some(r) => {
                        response.data.push(r)
                    },
                    None => {
                        break;
                    },
                }
            };
        },
        Err(e) => {
            response.set_code(StatusCode::INTERNAL_SERVER_ERROR, e.to_string());
            return Json(response);
        }
    }

    response.set_code(
        StatusCode::OK, 
        format!(
            "Found characters with secret_code: {}",
            secret
        ));
    Json(response)
}

#[utoipa::path(
    get,
    path = "/api/character/{secret}/{pass}",
    responses((
        status = 200, 
        description = "Found characters with : {secret} and {pass}", 
        body = CharDetialedResponse,
    ),
    (
        status = 500, 
        description = "Internal error occured", 
        body = CharDetialedResponse 
    )),
    params(
        (
            "secret" = String, 
            Path, 
            description = "String set by the user to get their data"
        ),
        (
            "pass" = String,
            Path,
            description = "String generated by the api for the specific game."
        )
    )
)]
pub async fn get_character_for_game(
    Extension(mongo): Extension<Database>,
    Path(secret): Path<String>,
    Path(pass): Path<String>,
) -> Json<DetailedResponse<Character>> {
    let mut response =
        DetailedResponse::new(Character::new());
    response.set_code(
        StatusCode::OK,
        format!(
            "Found your character in game: {}",
            pass
        ));
    Json(response)
}
